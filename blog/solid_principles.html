<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><link rel="preload" href="/_next/static/css/f2021f25e300475a51bd.css" as="style"/><link rel="stylesheet" href="/_next/static/css/f2021f25e300475a51bd.css" data-n-g=""/><noscript data-n-css=""></noscript><link rel="preload" href="/_next/static/chunks/webpack-189c53927ffd3caf09c3.js" as="script"/><link rel="preload" href="/_next/static/chunks/framework-92300432a1172ef1338b.js" as="script"/><link rel="preload" href="/_next/static/chunks/main-71948af4b0f09c0fc30e.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/_app-5322baa14be01c82b949.js" as="script"/><link rel="preload" href="/_next/static/chunks/107-417443aae65591804728.js" as="script"/><link rel="preload" href="/_next/static/chunks/pages/blog/%5Bslug%5D-d75f6880ed1a5dc5dad4.js" as="script"/></head><body><div id="__next"><div style="height:10px"></div><main class="container"><div class="btn btn-back">Back</div><div class="card card-page"><h1 class="post-title">Solid</h1><div class="post-date">Posted on <!-- -->Mon 29 Dec 2021</div><img src="/images/posts/solid.jpeg" alt=""/><div class="post-body"><div><h2 id="the-principles-">The principles :</h2>
<ul>
<li>Single-responsibility principle</li>
<li>Open-Closed principle</li>
<li>Liskov substitution principle</li>
<li>Interface segregation principle</li>
<li>Dependency inversion principle<br/>
<br/></li>
</ul>
<h3 id="single-responsibility-principle">Single Responsibility Principle</h3>
<hr>
<p>A class should do one thing and therefore it should have only a single reason to change</p>
<pre><code>class Vehicle {
    public:
    int speed;
    Engine* engine;
    int mileage;
    void changeSpeed();
    void changeDirection();
    void repair();            // Violate SRP
}

// FIX
class Garage {
    public:
    void repair(Vehicle* vehicle);
}
</code></pre>
<br/>
<br/>

<h3 id="open-closed-principle">Open Closed Principle</h3>
<hr>
<p>Classes should be open for extension and closed to modification.</p>
<pre><code>class Garage {
    public:
    void repairLocal(Vehicle* vehicle);
    void repairBranded(Vehicle* vehicle); // Violate Open closed principle
}
// Addition of new tyep of repair will result into modfying the existing class.

//FIX
class Garage {
    public:
    virtual void rapair(Vehicle* vehicle) = 0;
}

class LocalGarage : public Garage {
    public:
    void repair(Vehicle* vehicle);  //Local repair
}

class BrandedGarage : public Garage {
    public:
    void repair(Vehicle* vehicle);  //Branded repair
}
</code></pre>
<br/>
<br/>

<h3 id="liskov-substitution-principle">Liskov Substitution Principle</h3>
<hr>
<p>Subclasses should be substitutable for their base classes</p>
<blockquote>
<p>Liskov Substitution Principle is an extension of the Open Close Principle and is violated when you have written code that throws “not implemented exceptions” or you hide methods in a derived class that have been marked as virtual in the base class.</p>
</blockquote>
<pre><code>class Vehicle {
    public:
    virtual void changeGear();
}

class Scooti : public Vehicle {
    public:
    void changeGear(){
        throw(&quot;Not implemented&quot;); //Violate Liskov substitution principle
    }
}

// FIX
class Vehicle {
}

class GearVehicle : public Vehicle {
    public:
    virtual void changeGear();
}

class NonGearVehicle : public Vehicle {
}

class Scooti : public NonGearVehicle {
}
</code></pre>
<br/>
<br/>

<h3 id="interface-segregation-principle">Interface Segregation Principle</h3>
<hr>
<p>Separating the interfaces</p>
<blockquote>
<p>The principle states that many client-specific interfaces are better than one general-purpose interface. Clients should not be forced to implement a function they do no need.</p>
</blockquote>
<pre><code>// FIX
class Vehicle { // Common Base Interface
}

class GearVehicle : public Vehicle { // Segregated Interface 1
    public:
    virtual void changeGear();
}

class NonGearVehicle : public Vehicle { // Segregated Interface 1
}

class Scooti : public NonGearVehicle { // Implement only what required
}
</code></pre>
<br/>
<br/>

<h3 id="lsp-vs-isp">LSP vs ISP</h3>
<blockquote>
<p>LSP: The receiver must honor the contracts it promises.
ISP: The caller shouldn’t depend on more of the receiver’s interface than it needs.
Where they fit: If you apply the ISP, you use only a slice of the receiver’s full interface. But according to LSP, the receiver must still honor that slice. If you fail to apply ISP, there can be a temptation to violate LSP. Because “this method doesn’t matter, it won’t actually be called.”</p>
</blockquote>
<p>Liskov Substitution addresses <strong>Subtypes</strong> design whereas Interface Segregation addresses <strong>Basetypes</strong> design.
<br/>
<br/></p>
<h3 id="dependency-inversion-principle">Dependency Inversion Principle</h3>
<hr>
<p>Our classes should depend upon interfaces or abstract classes instead of concrete classes and functions</p>
<pre><code>class Vehicle {
}

class Car : public Vehicle {
}

class Garage {
public:
    void repair(Vehicle* vehicle); // depends on Vehicle interface rather then on Car
}
</code></pre>
</div></div></div><div class="btn btn-back">Back</div></main><footer class="Home_footer__1WdhD"><a href="/"><span class="Home_logo__1YbrH"><img src="/_next/static/images/coder-8d005b49cfa1c2f47c55f4a7c4a4556e.jpg" alt="Subhash Jha" width="40" height="40"/></span> <!-- -->subhashjha.in</a></footer></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"frontMatter":{"title":"Solid","date":"Mon 29 Dec 2021","excerpt":"Set of rules each programmer should adhere to in order to make the code more secure, robust and extensible. This is my attempt to make it easier to understand with the help of simple examples.","cover_image":"/images/posts/solid.jpeg"},"slug":"solid_principles","content":" \n\n## The principles :\n- Single-responsibility principle\n- Open-Closed principle\n- Liskov substitution principle\n- Interface segregation principle\n- Dependency inversion principle\n\u003cbr/\u003e\n\u003cbr/\u003e\n\n### Single Responsibility Principle\n---\nA class should do one thing and therefore it should have only a single reason to change\n```\nclass Vehicle {\n\tpublic:\n\tint speed;\n\tEngine* engine;\n\tint mileage;\n\tvoid changeSpeed();\n\tvoid changeDirection();\n\tvoid repair();            // Violate SRP\n}\n\n// FIX\nclass Garage {\n\tpublic:\n\tvoid repair(Vehicle* vehicle);\n}\n```\n\u003cbr/\u003e\n\u003cbr/\u003e\n\n### Open Closed Principle\n---\nClasses should be open for extension and closed to modification.\n```\nclass Garage {\n\tpublic:\n\tvoid repairLocal(Vehicle* vehicle);\n\tvoid repairBranded(Vehicle* vehicle); // Violate Open closed principle\n}\n// Addition of new tyep of repair will result into modfying the existing class.\n\n//FIX\nclass Garage {\n\tpublic:\n\tvirtual void rapair(Vehicle* vehicle) = 0;\n}\n\nclass LocalGarage : public Garage {\n\tpublic:\n\tvoid repair(Vehicle* vehicle);  //Local repair\n}\n\nclass BrandedGarage : public Garage {\n\tpublic:\n\tvoid repair(Vehicle* vehicle);  //Branded repair\n}\n\n```\n\u003cbr/\u003e\n\u003cbr/\u003e\n\n### Liskov Substitution Principle\n---\nSubclasses should be substitutable for their base classes\n\u003e Liskov Substitution Principle is an extension of the Open Close Principle and is violated when you have written code that throws “not implemented exceptions” or you hide methods in a derived class that have been marked as virtual in the base class.\n```\nclass Vehicle {\n\tpublic:\n\tvirtual void changeGear();\n}\n\nclass Scooti : public Vehicle {\n\tpublic:\n\tvoid changeGear(){\n\t\tthrow(\"Not implemented\"); //Violate Liskov substitution principle\n\t}\n}\n\n// FIX\nclass Vehicle {\n}\n\nclass GearVehicle : public Vehicle {\n\tpublic:\n\tvirtual void changeGear();\n}\n\nclass NonGearVehicle : public Vehicle {\n}\n\nclass Scooti : public NonGearVehicle {\n}\n```\n\u003cbr/\u003e\n\u003cbr/\u003e\n\n### Interface Segregation Principle\n---\nSeparating the interfaces\n\u003e The principle states that many client-specific interfaces are better than one general-purpose interface. Clients should not be forced to implement a function they do no need.\n```\n// FIX\nclass Vehicle { // Common Base Interface\n}\n\nclass GearVehicle : public Vehicle { // Segregated Interface 1\n\tpublic:\n\tvirtual void changeGear();\n}\n\nclass NonGearVehicle : public Vehicle { // Segregated Interface 1\n}\n\nclass Scooti : public NonGearVehicle { // Implement only what required\n}\n```\n\u003cbr/\u003e\n\u003cbr/\u003e\n\n### LSP vs ISP\n\u003e LSP: The receiver must honor the contracts it promises.\nISP: The caller shouldn’t depend on more of the receiver’s interface than it needs.\nWhere they fit: If you apply the ISP, you use only a slice of the receiver’s full interface. But according to LSP, the receiver must still honor that slice. If you fail to apply ISP, there can be a temptation to violate LSP. Because “this method doesn’t matter, it won’t actually be called.”\n\nLiskov Substitution addresses **Subtypes** design whereas Interface Segregation addresses **Basetypes** design.\n\u003cbr/\u003e\n\u003cbr/\u003e\n\n### Dependency Inversion Principle\n---\nOur classes should depend upon interfaces or abstract classes instead of concrete classes and functions\n\n```\nclass Vehicle {\n}\n\nclass Car : public Vehicle {\n}\n\nclass Garage {\npublic:\n\tvoid repair(Vehicle* vehicle); // depends on Vehicle interface rather then on Car\n}\n```"},"__N_SSG":true},"page":"/blog/[slug]","query":{"slug":"solid_principles"},"buildId":"yscxjXxWv_rw56RHuw6Y1","isFallback":false,"gsp":true}</script><script nomodule="" src="/_next/static/chunks/polyfills-eef578260fd80f8fff94.js"></script><script src="/_next/static/chunks/webpack-189c53927ffd3caf09c3.js" async=""></script><script src="/_next/static/chunks/framework-92300432a1172ef1338b.js" async=""></script><script src="/_next/static/chunks/main-71948af4b0f09c0fc30e.js" async=""></script><script src="/_next/static/chunks/pages/_app-5322baa14be01c82b949.js" async=""></script><script src="/_next/static/chunks/107-417443aae65591804728.js" async=""></script><script src="/_next/static/chunks/pages/blog/%5Bslug%5D-d75f6880ed1a5dc5dad4.js" async=""></script><script src="/_next/static/yscxjXxWv_rw56RHuw6Y1/_buildManifest.js" async=""></script><script src="/_next/static/yscxjXxWv_rw56RHuw6Y1/_ssgManifest.js" async=""></script></body></html>