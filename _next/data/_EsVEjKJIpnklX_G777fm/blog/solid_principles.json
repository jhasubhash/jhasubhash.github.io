{"pageProps":{"frontMatter":{"title":"SOLID Principles","date":"Mon 29 Dec 2021","excerpt":"Set of rules each programmer should adhere to in order to make the code more secure, robust and extensible. This is my attempt to make it easier to understand with the help of simple examples.","cover_image":"/images/posts/solid.jpeg"},"slug":"solid_principles","content":" \n\n## The principles :\n- Single-responsibility principle\n- Open-Closed principle\n- Liskov substitution principle\n- Interface segregation principle\n- Dependency inversion principle\n<br/>\n<br/>\n\n### Single Responsibility Principle\n---\nA class should do one thing and therefore it should have only a single reason to change\n```\nclass Vehicle {\n\tpublic:\n\tint speed;\n\tEngine* engine;\n\tint mileage;\n\tvoid changeSpeed();\n\tvoid changeDirection();\n\tvoid repair();            // Violate SRP\n}\n\n// FIX\nclass Garage {\n\tpublic:\n\tvoid repair(Vehicle* vehicle);\n}\n```\n<br/>\n<br/>\n\n### Open Closed Principle\n---\nClasses should be open for extension and closed to modification.\n```\nclass Garage {\n\tpublic:\n\tvoid repairLocal(Vehicle* vehicle);\n\tvoid repairBranded(Vehicle* vehicle); // Violate Open closed principle\n}\n// Addition of new tyep of repair will result into modfying the existing class.\n\n//FIX\nclass Garage {\n\tpublic:\n\tvirtual void rapair(Vehicle* vehicle) = 0;\n}\n\nclass LocalGarage : public Garage {\n\tpublic:\n\tvoid repair(Vehicle* vehicle);  //Local repair\n}\n\nclass BrandedGarage : public Garage {\n\tpublic:\n\tvoid repair(Vehicle* vehicle);  //Branded repair\n}\n\n```\n<br/>\n<br/>\n\n### Liskov Substitution Principle\n---\nSubclasses should be substitutable for their base classes\n> Liskov Substitution Principle is an extension of the Open Close Principle and is violated when you have written code that throws “not implemented exceptions” or you hide methods in a derived class that have been marked as virtual in the base class.\n```\nclass Vehicle {\n\tpublic:\n\tvirtual void changeGear();\n}\n\nclass Scooti : public Vehicle {\n\tpublic:\n\tvoid changeGear(){\n\t\tthrow(\"Not implemented\"); //Violate Liskov substitution principle\n\t}\n}\n\n// FIX\nclass Vehicle {\n}\n\nclass GearVehicle : public Vehicle {\n\tpublic:\n\tvirtual void changeGear();\n}\n\nclass NonGearVehicle : public Vehicle {\n}\n\nclass Scooti : public NonGearVehicle {\n}\n```\n<br/>\n<br/>\n\n### Interface Segregation Principle\n---\nSeparating the interfaces\n> The principle states that many client-specific interfaces are better than one general-purpose interface. Clients should not be forced to implement a function they do no need.\n```\n// FIX\nclass Vehicle { // Common Base Interface\n}\n\nclass GearVehicle : public Vehicle { // Segregated Interface 1\n\tpublic:\n\tvirtual void changeGear();\n}\n\nclass NonGearVehicle : public Vehicle { // Segregated Interface 1\n}\n\nclass Scooti : public NonGearVehicle { // Implement only what required\n}\n```\n<br/>\n<br/>\n\n### LSP vs ISP\n> LSP: The receiver must honor the contracts it promises.\nISP: The caller shouldn’t depend on more of the receiver’s interface than it needs.\nWhere they fit: If you apply the ISP, you use only a slice of the receiver’s full interface. But according to LSP, the receiver must still honor that slice. If you fail to apply ISP, there can be a temptation to violate LSP. Because “this method doesn’t matter, it won’t actually be called.”\n\nLiskov Substitution addresses **Subtypes** design whereas Interface Segregation addresses **Basetypes** design.\n<br/>\n<br/>\n\n### Dependency Inversion Principle\n---\nOur classes should depend upon interfaces or abstract classes instead of concrete classes and functions\n\n```\nclass Vehicle {\n}\n\nclass Car : public Vehicle {\n}\n\nclass Garage {\npublic:\n\tvoid repair(Vehicle* vehicle); // depends on Vehicle interface rather then on Car\n}\n```","url":"https://subhashjha.in/blog/solid_principles"},"__N_SSG":true}